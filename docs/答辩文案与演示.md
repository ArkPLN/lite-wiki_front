### 1. 社区交互模块

**核心定位**：基于 **CQRS (命令查询职责分离)** 模式构建的高并发社区服务。

- **CRUD 任务清单**：
  
  - **C (Create) - 发布内容**：
    - 接收前端富文本数据 -> 写入 `Discussions` 主表 -> 返回生成的 ID。
    - *技术点*：使用 Command 模式封装写入请求。
  - **R (Read) - 视图查询**：
    - 获取社区动态流、讨论列表及详情。
    - *技术点*：针对读操作优化，支持基于游标（Cursor）的分页查询，适应无限滚动列表。
  - **U (Update) - 状态变更（点赞）**：
    - 当用户点赞时，创建一条 `Like` 记录。
    - *技术点*：触发 `Discussion` 实体的 `LikeCount` 字段原子性 +1，保证高并发下的计数准确。
  - **D (Delete) - 关联移除（取消点赞）**：
    - 当用户取消点赞时，系统识别已存在的点赞记录。
    - *技术点*：执行 **硬删除 (Hard Delete)**，从数据库物理移除该条 `Like` 关联，并触发聚合根的计数回滚，确保数据一致性。

- **演示/答辩话术**：
  
  > "我负责的是**社区交互模块**。考虑到社区功能存在明显的'读多写少'特征，我采用了 **CQRS (命令查询职责分离)** 架构。
  > 传统的 CRUD 往往将读写逻辑混杂，而我将'发帖/点赞'等写操作封装为 **Command**，将'列表查询'封装为 **Query**。这样做实现了业务逻辑的解耦，代码结构更清晰，也为系统未来应对高并发读取留出了扩展空间。
  > 
  > 在前端实现上，我运用了 **React Query**（TanStack Query）这一现代数据获取库，它完美契合了 CQRS 模式的 Query 端。通过自动缓存、后台更新和失效管理，实现了高效的'读操作'优化，特别是在无限滚动列表场景下，基于游标的分页查询配合 React Query 的 `useInfiniteQuery` 钩子，为用户提供了流畅的浏览体验。
  > 
  > 对于'写操作'，我采用了 React Query 的 `useMutation` 钩子，配合 **乐观更新** 策略。当用户点赞时，前端立即更新 UI，同时发送 Command 到后端，这种设计大大提升了用户体验。在技术实现上，我使用了 **Zustand** 进行轻量级状态管理，结合 **Material-UI** 组件库和 **TailwindCSS** 实现了响应式设计。
  > 
  > 整个前端架构基于 **Vite + React 18** 构建，利用 **SWC** 编译器提升开发性能。通过 **TypeScript** 确保类型安全，并使用 **路径别名**（@/*）优化代码组织。这种工程化实践不仅提高了开发效率，也为后续维护和扩展奠定了良好基础。"

---

### 2. 文档资产管理

**核心定位**：非结构化数据的**全生命周期管理**（AI 处理流程的上游）。

- **CRUD 任务清单**：
  
  - **C (Create) - 资产入库**：
    - 接收 `IFormFile` 文件流 -> 持久化存储（本地磁盘/MinIO） -> 在数据库创建元数据记录（文件名、大小、MIME类型）。
  - **R (Read) - 列表与属性**：
    - 查询文档列表，展示文件名、上传时间及处理状态（如：上传中、解析完成）。
  - **U (Update) - 元数据修正**：
    - 修改文档的显示名称或备注信息。
    - *注意*：此处仅更新数据库字段，不涉及底层文件内容的变动。
  - **D (Delete) - 软删除机制**：
    - 将数据库中的 `IsDeleted` 字段标记为 `true`。
    - *技术点*：实现**软删除 (Soft Delete)**，保留数据可恢复性，避免用户误操作导致资产永久丢失。

- **演示/答辩话术**：
  
  > "我负责的是 **非结构化文档的生命周期管理**。它是核心 AI 引擎的'数据后勤部'。
  > 我主要解决的是文件流的接收与持久化问题，支持多种格式文档的解析预处理。特别是在删除功能上，我遵循工业界标准设计了 **软删除 (Soft Delete)** 机制，在保证用户体验的同时，也确保了数据的安全性和可追溯性。
  > 
  > 在前端实现中，我采用了 **MdEditorRt** 作为核心 Markdown 编辑器，它提供了丰富的编辑功能和实时预览能力。通过 **React Query** 管理文档状态，实现了乐观更新和自动缓存，确保用户操作流畅。我还实现了基于 **React Hook Form** 的表单验证，结合 **Zustand** 进行全局状态管理，使得文档编辑体验更加连贯。
  > 
  > 文件上传部分，我使用了 **Axios** 拦截器处理上传进度，并通过 **React Query** 的 `useMutation` 实现上传状态管理。整个文档管理流程被封装在 **React Context** 中，确保跨组件的数据一致性。这种设计不仅提高了代码复用性，也为后续功能扩展提供了良好的架构基础。"

---

### 3. 会话状态管理

**核心定位**：LLM 对话链路的**上下文 (Context) 持久化**。

- **CRUD 任务清单**：
  
  - **C (Create) - 开启会话**：
    - 在 `ChatSessions` 表中初始化一条记录，生成唯一的 `SessionId`，初始化系统提示词（System Prompt）。
  - **R (Read) - 加载历史**：
    - 根据 `SessionId` 检索 `ChatMessages` 表，按时间戳正序返回完整的对话历史，用于还原上下文。
  - **U (Update) - 会话重命名**：
    - 用户手动修改会话标题，或根据首轮对话内容自动更新标题。
  - **D (Delete) - 会话清理**：
    - 删除指定会话。
    - *技术点*：利用数据库的**级联删除 (Cascade Delete)** 特性，同步清除该会话关联的所有消息记录，重置上下文环境。

- **演示/答辩话术**：
  
  > "我负责的是 **AI 对话的状态管理**。由于 LLM 模型本身是无状态的（Stateless），为了实现连续对话体验，我设计了这个会话持久化层。
  > 通过结构化存储 `Session` 和 `Message`，我不只保存了聊天记录，更为核心的 RAG 检索提供了多轮对话的**上下文锚点**，确保用户在刷新页面或切换设备后，AI 依然能接上之前的思维链路。
  > 
  > 在前端实现上，我采用了 **Zustand** 作为轻量级状态管理库，专门设计了 `chatStore` 来管理会话状态。这个 store 包含了活跃会话ID、消息列表、流式响应内容等关键状态，并提供了一系列原子操作方法。为了处理 AI 的流式响应，我实现了 **EventSource** 解析器，能够实时处理 SSE (Server-Sent Events) 数据流，实现逐字显示效果。
  > 
  > 我还利用 **React Query** 的 `useMutation` 和 `useInfiniteQuery` 钩子管理会话的创建和消息加载，配合自定义的 `processEventStream` 函数处理流式数据。整个会话管理模块被设计为高度可复用的 Hook 集合，包括 `useChatSessions`、`useChatSessionById`、`useCreateChatSession` 等，这种设计模式不仅提高了代码的可维护性，也为未来添加新功能（如会话分享、导出等）提供了扩展点。"

---

### 4. 团队与权限服务

**核心定位**：基于 **RBAC (基于角色的访问控制)** 的多用户协作模块。

- **CRUD 任务清单**：
  
  - **C (Create) - 组建团队**：
    - 创建 `Team` 实体，并将创建者自动关联为 `Owner` 角色。
  - **R (Read) - 成员视图**：
    - 联表查询 `TeamMembers` 和 `Users`，展示团队组织架构及成员状态。
  - **U (Update) - 权限变更**：
    - 修改成员角色（如：将 Member 提升为 Admin），或更新团队的基础信息（名称、公告）。
  - **D (Delete) - 成员移除**：
    - 将成员移除出团队，或解散整个团队空间。
    - *技术点*：处理关联数据的清理，确保无残留权限。

- **演示/答辩话术**：
  
  > "我负责系统的 **安全边界与团队协作** 模块。虽然知识库是个人的，但在实际应用中，团队共享必不可少。
  > 我基于 **RBAC 模型** 实现了团队管理服务，涵盖了从团队创建、成员邀请到权限变更的完整闭环。这不仅满足了多用户协作的需求，更重要的是实现了严格的数据隔离，确保未授权用户无法越权访问团队资源。
  > 
  > 在前端实现中，我设计了一套完整的权限控制机制。首先，通过 **React Context** 创建了 `AuthContext`，提供全局的用户认证状态和权限检查方法。在路由层面，我实现了 **ProtectedRoute** 组件，根据用户角色动态渲染不同的页面内容。对于团队管理页面，我使用了 **条件渲染** 技术，只有具备相应权限的用户才能看到管理功能。
  > 
  > 在团队成员管理部分，我采用了 **Modal + Form** 的设计模式，实现了成员邀请和角色编辑功能。通过 **React Hook Form** 处理表单验证，结合 **Yup** 进行数据校验，确保输入数据的合法性。我还实现了 **乐观更新** 策略，当用户修改成员角色时，前端立即更新 UI，同时发送请求到后端，这种设计大大提升了用户体验。整个权限系统被设计为高度可配置的，支持动态角色定义和细粒度权限控制，为系统未来的扩展提供了良好的基础。"

---

### 5. 用户身份服务

**核心定位**：系统的**身份认证 (Identity)** 与消息总线。

- **CRUD 任务清单**：
  
  - **C (Create)**: 用户注册，初始化用户配置。
  - **R (Read)**: 获取个人资料 (Profile)、查询系统通知列表。
  - **U (Update)**: 修改密码、更新头像、标记通知为已读。
  - **D (Delete)**: 注销账户，清理用户敏感数据。

- **演示/答辩话术**：
  
  > "我构建了系统的 **身份认证与基础服务模块**。
  > 除了实现标准的用户鉴权流程外，我还集成了系统级的 **异步消息通知** 功能。当后台的文档解析任务完成时，我的模块会负责将状态实时推送到前端，形成了用户操作的完整反馈闭环。
  > 
  > 在前端实现中，我采用了 **JWT (JSON Web Token)** 作为身份认证机制，通过 **Axios 拦截器** 自动处理请求头的 Token 注入。我设计了一个全局的 `useUserStore` (基于 Zustand)，管理用户的登录状态、个人资料和权限信息。这个 store 提供了持久化存储能力，确保页面刷新后用户状态不会丢失。
  > 
  > 在用户认证流程中，我实现了多种登录方式：常规邮箱密码登录以及匿名登录。通过 **React Query** 的 `useMutation` 钩子管理登录请求，配合自定义的错误处理机制，提供了友好的用户提示。对于密码重置功能，我采用了 **邮箱验证** 流程，确保安全性。
---

### 6. 核心 AI 引擎 (RagService)

**核心定位**：负责向量化处理 (ETL)、混合检索与一致性维护的核心计算引擎。

- **CRUD 任务清单**：
  
  - **C (Create) - 向量化入库 (ETL Pipeline)**
    - **Extract**: 从原始文档提取文本。
    - **Transform**: 执行 **Markdown-aware Chunking**（基于语法的智能分块），利用 Semantic Kernel 识别代码块与段落边界，保持语义完整；调用 **本地 ONNX 模型** 完成 Embedding 计算。
    - **Load**: 将处理后的 `DocumentVector` 批量写入向量数据库。
  - **R (Read) - RAG 混合检索**
    - **Vectorization**: 将用户的自然语言 Query 转化为高维向量。
    - **Search**: 在 `Pgvector` 中执行 **ANN (近似最近邻)** 搜索，计算余弦相似度，并过滤多租户权限。
    - **Context Injection**: 动态组装 Prompt（系统提示词 + 检索到的 Top-K 片段）。
    - **Generation**: 驱动 LLM 推理，并通过 **SSE (Server-Sent Events)** 协议流式输出结果。
  - **U (Update) - 原子性索引重建**
    - **逻辑**: 当源文档内容更新时，旧的向量切片即刻失效。
    - **策略**: 采用 **Delete-Then-Insert** 策略。
    - **一致性**: 在 `BeginTransactionAsync` 事务块中，先清除旧向量，再写入新生成的向量。这确保了在高并发下，知识库永远不会处于"一半新一半旧"的中间状态。
  - **D (Delete) - 向量空间清洗**
    - **逻辑**: 物理移除文档对应的向量数据。
    - **目的**: 不仅是删记录，而是执行 **Hard Delete** 从向量索引中抹除 Embeddings。
    - **意义**: 防止 RAG 检索时命中已删除的"僵尸数据"，从而从根本上避免 AI 产生幻觉 (Hallucination)。

- **演示/答辩话术**：
  
  > "我负责的是项目的**核心 RAG 引擎**。
  > 与普通的增删改查不同，我的模块主要处理 **非结构化数据的向量化**。
  > 在**创建**阶段，我实现了基于 Markdown 语法的智能切片，配合本地 ONNX 模型进行向量计算；
  > 在**更新**阶段，我使用了数据库事务来保证向量索引重建的原子性，确保检索结果的一致性；
  > 在**检索**阶段，我利用 Pgvector 实现了高精度的语义搜索，并支持流式输出。
  > 这套机制确保了 AI 能够基于准确、私有的知识库回答用户问题。
  > 
  > 在前端实现中，我设计了一套完整的 AI 交互系统。首先，通过 **React Query** 的 `useMutation` 钩子管理 AI 请求，配合自定义的 `processEventStream` 函数处理服务端发送的流式数据。我实现了 **打字机效果**，通过逐字更新 UI 提供流畅的用户体验。在知识库管理界面，我使用了 **Recharts** 库创建可视化图表，直观展示文档分布和向量存储情况。
  > 
  > 对于 AI 对话界面，我设计了一个 **多轮对话管理** 系统，通过 `chatStore` 管理会话状态和消息历史，为未来添加更多 AI 功能（如多模态理解、知识图谱等）提供了良好的架构基础。"